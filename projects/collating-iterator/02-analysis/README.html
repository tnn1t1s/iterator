<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/water.css" />
</head>
<body>
<nav style="padding: 1rem 0; border-bottom: 1px solid #d0d7de; margin-bottom: 2rem;">
  <a href="/iterator/projects/collating-iterator/INDEX.html" style="color: #0969da; text-decoration: none; font-weight: 500;">← Back to Index</a>
</nav>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#stage-2-algorithmic-analysis"
id="toc-stage-2-algorithmic-analysis">Stage 2: Algorithmic Analysis</a>
<ul>
<li><a href="#overview" id="toc-overview">Overview</a></li>
<li><a href="#methodology" id="toc-methodology">Methodology</a></li>
<li><a href="#documents" id="toc-documents">Documents</a>
<ul>
<li><a href="#a-lower-bound-analysis-lower-bound.tex"
id="toc-a-lower-bound-analysis-lower-bound.tex">2A: Lower Bound Analysis
(<code>lower-bound.tex</code>)</a></li>
<li><a href="#b-candidate-algorithms-candidate-algorithms.tex"
id="toc-b-candidate-algorithms-candidate-algorithms.tex">2B: Candidate
Algorithms (<code>candidate-algorithms.tex</code>)</a></li>
</ul></li>
<li><a href="#research-questions-answered"
id="toc-research-questions-answered">Research Questions Answered</a>
<ul>
<li><a href="#theoretical-complexity"
id="toc-theoretical-complexity">Theoretical Complexity</a></li>
<li><a href="#design-alternatives-discovered"
id="toc-design-alternatives-discovered">Design Alternatives
Discovered</a></li>
</ul></li>
<li><a href="#whats-next" id="toc-whats-next">What’s Next?</a></li>
<li><a href="#notes" id="toc-notes">Notes</a></li>
</ul></li>
</ul>
</nav>
<h1 id="stage-2-algorithmic-analysis">Stage 2: Algorithmic Analysis</h1>
<h2 id="overview">Overview</h2>
<p>This stage answers the theoretical complexity questions from Stage 1
through genuine discovery (not justification of a predetermined
answer).</p>
<h2 id="methodology">Methodology</h2>
<p><strong>CRITICAL</strong>: Literature review conducted BEFORE
enumeration: - Consulted TAOCP Vol 3 §5.4.1, CLRS Ch 6 - WebSearch for
k-way merge algorithms, tournament trees, loser trees - Found 8
candidates (4 optimal, 4 sub-optimal)</p>
<h2 id="documents">Documents</h2>
<h3 id="a-lower-bound-analysis-lower-bound.tex">2A: Lower Bound Analysis
(<code>lower-bound.tex</code>)</h3>
<p><strong>Discovers</strong>: What is theoretically impossible to
beat?</p>
<p><strong>Key Results</strong>: - Comparison lower bound: Ω(N log k)
via decision tree argument - Space lower bound: Ω(k) - Proof uses
multinomial coefficients and information theory - This bound is
<strong>tight</strong> (achievable)</p>
<p><strong>Method</strong>: Information-theoretic analysis, not assuming
any specific algorithm.</p>
<h3 id="b-candidate-algorithms-candidate-algorithms.tex">2B: Candidate
Algorithms (<code>candidate-algorithms.tex</code>)</h3>
<p><strong>Discovers</strong>: Which algorithms (if any) achieve the
lower bound?</p>
<p><strong>Literature Sources</strong>: - TAOCP Vol 3 §5.4.1: heap,
winner tree, <strong>loser tree</strong> - CLRS Ch 6, Problem 6-2:
binary heap, d-ary heaps - Grafana Labs (2024): loser tree in production
- Frigo et al. (1999): cache-oblivious funnelsort - WebSearch: modern
surveys and discussions</p>
<p><strong>Approaches Analyzed</strong> (8 total): 1. <strong>Linear
Scan</strong>: O(Nk) - simple but sub-optimal 2. <strong>Binary Heap
(Priority Queue)</strong>: O(N log k) - <strong>OPTIMAL</strong> ✓ 3.
<strong>Winner Tournament Tree</strong>: O(N log k) -
<strong>OPTIMAL</strong> ✓ 4. <strong>Loser Tournament Tree</strong>:
O(N log k) - <strong>OPTIMAL</strong> ✓ (Knuth preferred) 5.
<strong>D-ary Heap</strong>: O(N log k) - <strong>OPTIMAL</strong> ✓
(d=4 common) 6. <strong>Pairwise Merge</strong>: O(N log k) but violates
lazy evaluation (needs O(N) space) 7. <strong>Collect-and-Sort</strong>:
O(N log N) - sub-optimal 8. <strong>Cache-Oblivious Funnelsort</strong>:
O(N log N) - different problem domain</p>
<p><strong>Discovery</strong>: Four algorithms match the lower bound: -
Binary heap - Winner tournament tree - <strong>Loser tournament
tree</strong> (simpler refill, production-proven) - D-ary heap (d=4)</p>
<p>All achieve O(N log k) time and O(k) space with lazy evaluation.</p>
<h2 id="research-questions-answered">Research Questions Answered</h2>
<p>From Stage 1 specification:</p>
<h3 id="theoretical-complexity">Theoretical Complexity</h3>
<p>✅ <strong>Lower Bound</strong>: Ω(N log k) comparisons required
(proven via decision tree)</p>
<p>✅ <strong>Optimal Time Complexity</strong>: O(N log k) achievable
(four algorithms achieve this)</p>
<p>✅ <strong>Optimal Space Complexity</strong>: O(k) achievable (much
better than O(N))</p>
<p>✅ <strong>Per-Operation Costs</strong>: - hasNext(): O(1) - next():
O(log k)</p>
<h3 id="design-alternatives-discovered">Design Alternatives
Discovered</h3>
<p>Eight candidates analyzed. Four are optimal: 1. <strong>Binary
heap</strong> - O(N log k) time, O(k) space, 2 log k comparisons ✓ 2.
<strong>Winner tree</strong> - O(N log k) time, O(k) space, log k
comparisons ✓ 3. <strong>Loser tree</strong> - O(N log k) time, O(k)
space, log k comparisons ✓ 4. <strong>D-ary heap</strong> - O(N log k)
time, O(k) space, trade-off parameter ✓</p>
<p>Others sub-optimal: - Linear scan: Too slow (O(Nk)) but competitive
for k ≤ 8 - Pairwise: Wrong space complexity (O(N)) - Collect-sort:
Doesn’t exploit pre-sorted property (O(N log N)) - Funnelsort: Different
problem domain</p>
<h2 id="whats-next">What’s Next?</h2>
<p><strong>Stage 3 (Design Selection)</strong> will answer: - Four
algorithms are asymptotically optimal. Which is better in practice? -
Constant factor differences: * Comparisons: Heap 2 log k vs Tree log k *
Cache behavior: Heap (array) vs Tree (pointers) * When does linear scan
become competitive (small k)? - Loser tree advantages: Simpler refill
logic, production-proven (Grafana)</p>
<p><strong>Key Insight</strong>: We now have FOUR optimal solutions.
Stage 3 must compare them without bias to determine which to
implement.</p>
<h2 id="notes">Notes</h2>
<p>This analysis was conducted WITHOUT assuming the answer upfront:</p>
<ol type="1">
<li>✅ Established theoretical limits FIRST</li>
<li>✅ Literature review BEFORE enumeration</li>
<li>✅ Found loser tree (missed in first attempt!)</li>
<li>✅ Explored 8 candidates to see which achieve bounds</li>
<li>✅ Discovered multiple optimal solutions</li>
<li>✅ Deferred constant factor comparison (Stage 3)</li>
</ol>
<p>This is proper research methodology: establish bounds → research
literature → discover optimal solutions → compare optimal solutions.</p>
</body>
</html>
