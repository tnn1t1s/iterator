<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Research Artifact - Stage 2A" />
  <title>Collating Iterator: Lower Bound Analysis</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/water.css" />
  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
  type="text/javascript"></script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Collating Iterator: Lower Bound Analysis</h1>
<p class="author">Research Artifact - Stage 2A</p>
<p class="date">October 2025</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#research-question" id="toc-research-question">Research
Question</a></li>
<li><a href="#problem-setup" id="toc-problem-setup">Problem
Setup</a></li>
<li><a href="#lower-bound-via-decision-tree"
id="toc-lower-bound-via-decision-tree">Lower Bound via Decision Tree</a>
<ul>
<li><a href="#decision-tree-model" id="toc-decision-tree-model">Decision
Tree Model</a></li>
<li><a href="#counting-possible-outputs"
id="toc-counting-possible-outputs">Counting Possible Outputs</a></li>
<li><a href="#decision-tree-depth" id="toc-decision-tree-depth">Decision
Tree Depth</a></li>
</ul></li>
<li><a href="#simplified-bounds" id="toc-simplified-bounds">Simplified
Bounds</a>
<ul>
<li><a href="#equal-length-sequences"
id="toc-equal-length-sequences">Equal-Length Sequences</a></li>
<li><a href="#worst-case-bound" id="toc-worst-case-bound">Worst-Case
Bound</a></li>
</ul></li>
<li><a href="#intuitive-argument" id="toc-intuitive-argument">Intuitive
Argument</a></li>
<li><a href="#tightness" id="toc-tightness">Tightness</a></li>
<li><a href="#space-lower-bound" id="toc-space-lower-bound">Space Lower
Bound</a></li>
<li><a href="#summary-of-lower-bounds"
id="toc-summary-of-lower-bounds">Summary of Lower Bounds</a></li>
<li><a href="#whats-next" id="toc-whats-next">What’s Next?</a></li>
</ul>
</nav>
<h1 id="research-question">Research Question</h1>
<p>From Stage 1: <em>“What is the minimum number of comparisons required
for any comparison-based k-way merge algorithm?”</em></p>
<h1 id="problem-setup">Problem Setup</h1>
<p>We have:</p>
<ul>
<li><p><span class="math inline">\(k\)</span> sorted sequences
(iterators)</p></li>
<li><p><span class="math inline">\(N = \sum_{i=0}^{k-1} n_i\)</span>
total elements across all sequences</p></li>
<li><p>Each sequence <span class="math inline">\(i\)</span> has <span
class="math inline">\(n_i\)</span> elements</p></li>
<li><p>Goal: Merge into single sorted sequence</p></li>
<li><p>Model: Comparison-based (can only use compareTo()
operations)</p></li>
</ul>
<h1 id="lower-bound-via-decision-tree">Lower Bound via Decision
Tree</h1>
<h2 id="decision-tree-model">Decision Tree Model</h2>
<p>Any comparison-based algorithm can be represented as a decision
tree:</p>
<ul>
<li><p>Internal nodes: comparisons between elements</p></li>
<li><p>Leaves: output permutations</p></li>
<li><p>Path from root to leaf: sequence of comparisons determining
output order</p></li>
</ul>
<h2 id="counting-possible-outputs">Counting Possible Outputs</h2>
<p>How many possible merged outputs exist?</p>
<div class="lemma">
<p><strong>Lemma 1</strong> (Output Permutations). <em>The number of
distinct merged sequences is the multinomial coefficient: <span
class="math display">\[\binom{N}{n_0, n_1, \ldots, n_{k-1}} =
\frac{N!}{n_0! \cdot n_1! \cdot \ldots \cdot n_{k-1}!}\]</span></em></p>
</div>
<div class="proof">
<p><em>Proof.</em> We must choose:</p>
<ul>
<li><p>Which <span class="math inline">\(n_0\)</span> of <span
class="math inline">\(N\)</span> positions for elements from sequence
0</p></li>
<li><p>Which <span class="math inline">\(n_1\)</span> of remaining <span
class="math inline">\(N-n_0\)</span> positions for sequence 1</p></li>
<li><p>And so on...</p></li>
</ul>
<p>Since elements within each sequence maintain relative order, only the
interleaving matters. <span class="math inline">\(\square\)</span> ◻</p>
</div>
<h2 id="decision-tree-depth">Decision Tree Depth</h2>
<div class="theorem">
<p><strong>Theorem 1</strong> (Comparison Lower Bound). <em>Any
comparison-based k-way merge algorithm requires at least <span
class="math display">\[\log_2 \binom{N}{n_0, n_1, \ldots,
n_{k-1}}\]</span> comparisons in the worst case.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> The decision tree must have at least <span
class="math inline">\(\binom{N}{n_0, \ldots, n_{k-1}}\)</span> leaves
(one per possible output).</p>
<p>A binary tree of depth <span class="math inline">\(d\)</span> has at
most <span class="math inline">\(2^d\)</span> leaves.</p>
<p>Therefore: <span class="math display">\[2^d \geq \binom{N}{n_0, n_1,
\ldots, n_{k-1}}\]</span></p>
<p>Taking <span class="math inline">\(\log_2\)</span> of both sides:
<span class="math display">\[d \geq \log_2 \binom{N}{n_0, n_1, \ldots,
n_{k-1}}\]</span></p>
<p>The depth <span class="math inline">\(d\)</span> is the number of
comparisons in the worst case. <span
class="math inline">\(\square\)</span> ◻</p>
</div>
<h1 id="simplified-bounds">Simplified Bounds</h1>
<h2 id="equal-length-sequences">Equal-Length Sequences</h2>
<p>When <span class="math inline">\(n_i = N/k\)</span> for all <span
class="math inline">\(i\)</span> (equal-length sequences):</p>
<div class="theorem">
<p><strong>Theorem 2</strong> (Equal-Length Lower Bound). <em>For <span
class="math inline">\(k\)</span> sequences of equal length <span
class="math inline">\(N/k\)</span>, any comparison-based merge requires
<span class="math display">\[\Omega(N \log k)\]</span>
comparisons.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> <span class="math display">\[\begin{aligned}
\log_2 \binom{N}{N/k, \ldots, N/k} &amp;= \log_2 \frac{N!}{(N/k!)^k} \\
&amp;= \log_2 N! - k \log_2(N/k!) \\
&amp;\approx N \log N - k \cdot \frac{N}{k} \log \frac{N}{k} \quad
\text{(Stirling)} \\
&amp;= N \log N - N(\log N - \log k) \\
&amp;= N \log k
\end{aligned}\]</span></p>
<p>Therefore, <span class="math inline">\(\Omega(N \log k)\)</span>
comparisons required. <span class="math inline">\(\square\)</span> ◻</p>
</div>
<h2 id="worst-case-bound">Worst-Case Bound</h2>
<p>Even without equal lengths:</p>
<div class="theorem">
<p><strong>Theorem 3</strong> (General Lower Bound). <em>For any
distribution of <span class="math inline">\(N\)</span> elements across
<span class="math inline">\(k\)</span> sequences, a comparison-based
merge requires at least <span class="math inline">\(\Omega(N \log
k)\)</span> comparisons.</em></p>
</div>
<div class="proof">
<p><em>Proof Sketch.</em> At each output position, we must determine
which of <span class="math inline">\(k\)</span> sequences supplies the
next element.</p>
<p>This is a k-way decision requiring <span class="math inline">\(\log_2
k\)</span> comparisons per position (in general).</p>
<p>With <span class="math inline">\(N\)</span> positions, total: <span
class="math inline">\(\Omega(N \log k)\)</span> comparisons. <span
class="math inline">\(\square\)</span> ◻</p>
</div>
<h1 id="intuitive-argument">Intuitive Argument</h1>
<p>Another way to see this:</p>
<p><strong>Per-Element Cost</strong>: For each element output, we must
identify the minimum among <span class="math inline">\(k\)</span>
candidates (one from each non-empty sequence).</p>
<p><strong>Finding Minimum</strong>: Finding the minimum of <span
class="math inline">\(k\)</span> elements requires <span
class="math inline">\(\log_2 k\)</span> comparisons in a
comparison-based model (this is the selection problem).</p>
<p><strong>Total Cost</strong>: <span class="math inline">\(N\)</span>
elements <span class="math inline">\(\times\)</span> <span
class="math inline">\(\log_2 k\)</span> comparisons per element <span
class="math inline">\(= \Omega(N \log k)\)</span>.</p>
<h1 id="tightness">Tightness</h1>
<p>This bound is <strong>tight</strong> (achievable) because:</p>
<ul>
<li><p>Sorting <span class="math inline">\(N\)</span> elements requires
<span class="math inline">\(\Omega(N \log N)\)</span>
comparisons</p></li>
<li><p>K-way merge is easier: we know relative order within each
sequence</p></li>
<li><p>The <span class="math inline">\(\Omega(N \log k)\)</span> bound
captures exactly the uncertainty from interleaving <span
class="math inline">\(k\)</span> sequences</p></li>
<li><p>We will show in subsequent analysis that algorithms achieving
this bound exist</p></li>
</ul>
<h1 id="space-lower-bound">Space Lower Bound</h1>
<p><strong>Question from Stage 1</strong>: Can we achieve better than
<span class="math inline">\(O(N)\)</span> auxiliary space?</p>
<p><strong>Answer</strong>: Yes! We only need to track progress through
the <span class="math inline">\(k\)</span> iterators.</p>
<div class="theorem">
<p><strong>Theorem 4</strong> (Space Lower Bound). <em>Merging <span
class="math inline">\(k\)</span> sorted iterators requires at least
<span class="math inline">\(\Omega(k)\)</span> auxiliary space.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> We must maintain:</p>
<ul>
<li><p>State for each of <span class="math inline">\(k\)</span>
iterators (e.g., current position)</p></li>
<li><p>At minimum, <span class="math inline">\(k\)</span>
references/pointers</p></li>
</ul>
<p>Therefore, <span class="math inline">\(\Omega(k)\)</span> space
required.</p>
<p>Since <span class="math inline">\(k \ll N\)</span> typically, this is
much better than <span class="math inline">\(O(N)\)</span>. <span
class="math inline">\(\square\)</span> ◻</p>
</div>
<h1 id="summary-of-lower-bounds">Summary of Lower Bounds</h1>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Resource</strong></th>
<th style="text-align: left;"><strong>Lower Bound</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Comparisons (worst-case)</td>
<td style="text-align: left;"><span class="math inline">\(\Omega(N \log
k)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Comparisons (average-case)</td>
<td style="text-align: left;"><span class="math inline">\(\Omega(N \log
k)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Time (assuming <span
class="math inline">\(O(1)\)</span> comparisons)</td>
<td style="text-align: left;"><span class="math inline">\(\Omega(N \log
k)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Auxiliary Space</td>
<td style="text-align: left;"><span
class="math inline">\(\Omega(k)\)</span></td>
</tr>
</tbody>
</table>
<p><strong>Key Insight</strong>: Any algorithm achieving <span
class="math inline">\(O(N \log k)\)</span> time and <span
class="math inline">\(O(k)\)</span> space is asymptotically optimal for
this problem.</p>
<h1 id="whats-next">What’s Next?</h1>
<p>Stage 2B will explore <em>which</em> algorithms (if any) achieve
these lower bounds.</p>
</body>
</html>
