<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Research Artifact" />
  <title>Collating Iterator: Algorithmic Analysis</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/water.css" />
  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Collating Iterator: Algorithmic Analysis</h1>
<p class="author">Research Artifact</p>
<p class="date">October 2025</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#algorithm-description"
id="toc-algorithm-description">Algorithm Description</a></li>
<li><a href="#time-complexity" id="toc-time-complexity">Time
Complexity</a>
<ul>
<li><a href="#per-operation-analysis"
id="toc-per-operation-analysis">Per-Operation Analysis</a></li>
<li><a href="#total-complexity" id="toc-total-complexity">Total
Complexity</a></li>
</ul></li>
<li><a href="#space-complexity" id="toc-space-complexity">Space
Complexity</a></li>
<li><a href="#correctness-proof" id="toc-correctness-proof">Correctness
Proof</a>
<ul>
<li><a href="#loop-invariant" id="toc-loop-invariant">Loop
Invariant</a></li>
<li><a href="#proof-of-correctness" id="toc-proof-of-correctness">Proof
of Correctness</a></li>
</ul></li>
<li><a href="#constant-factors" id="toc-constant-factors">Constant
Factors</a>
<ul>
<li><a href="#comparison-operations"
id="toc-comparison-operations">Comparison Operations</a></li>
<li><a href="#memory-access-pattern"
id="toc-memory-access-pattern">Memory Access Pattern</a></li>
<li><a href="#branch-mispredictions"
id="toc-branch-mispredictions">Branch Mispredictions</a></li>
</ul></li>
<li><a href="#lower-bound" id="toc-lower-bound">Lower Bound</a></li>
<li><a href="#references" id="toc-references">References</a></li>
</ul>
</nav>
<h1 id="algorithm-description">Algorithm Description</h1>
<p>The heap-based collating iterator uses a binary min-heap to
efficiently select the minimum element across <span
class="math inline">\(k\)</span> sorted input iterators.</p>
<div class="algorithm">
<div class="algorithmic">
<p><strong>Initialize:</strong> <span class="math inline">\(H \gets
\emptyset\)</span> <span class="math inline">\(e \gets
I_i.\texttt{next()}\)</span> <span
class="math inline">\(H.\texttt{insert}((e, I_i))\)</span>
<strong>Operation hasNext():</strong> <span class="math inline">\(H \neq
\emptyset\)</span> <strong>Operation next():</strong>
<strong>throw</strong> NoSuchElementException <span
class="math inline">\((e, I) \gets H.\texttt{extractMin()}\)</span>
<span class="math inline">\(e&#39; \gets I.\texttt{next()}\)</span>
<span class="math inline">\(H.\texttt{insert}((e&#39;, I))\)</span>
<span class="math inline">\(e\)</span></p>
</div>
</div>
<h1 id="time-complexity">Time Complexity</h1>
<h2 id="per-operation-analysis">Per-Operation Analysis</h2>
<ul>
<li><p><strong>hasNext()</strong>: <span
class="math inline">\(O(1)\)</span></p>
<ul>
<li><p>Simple check: <span class="math inline">\(|H| &gt;
0\)</span></p></li>
</ul></li>
<li><p><strong>next()</strong>: <span class="math inline">\(O(\log
k)\)</span></p>
<ul>
<li><p>extractMin(): <span class="math inline">\(O(\log k)\)</span> for
heap sift-down</p></li>
<li><p>Iterator advance: <span class="math inline">\(O(1)\)</span>
amortized</p></li>
<li><p>insert(): <span class="math inline">\(O(\log k)\)</span> for heap
sift-up</p></li>
<li><p>Total: <span class="math inline">\(O(\log k)\)</span></p></li>
</ul></li>
<li><p><strong>Construction</strong>: <span class="math inline">\(O(k
\log k)\)</span> naive, <span class="math inline">\(O(k)\)</span> with
heapify</p>
<ul>
<li><p>Naive: <span class="math inline">\(k\)</span> insertions <span
class="math inline">\(\times\)</span> <span class="math inline">\(O(\log
k)\)</span> = <span class="math inline">\(O(k \log k)\)</span></p></li>
<li><p>Heapify: Build heap bottom-up in <span
class="math inline">\(O(k)\)</span> [CLRS Ch 6.3]</p></li>
</ul></li>
</ul>
<h2 id="total-complexity">Total Complexity</h2>
<p>Let <span class="math inline">\(N = \sum_{i=0}^{k-1} |I_i|\)</span>
be the total number of elements across all iterators.</p>
<div class="theorem">
<p><strong>Theorem 1</strong> (Time Complexity). <em>The heap-based
collating iterator processes all <span class="math inline">\(N\)</span>
elements in <span class="math inline">\(O(N \log k)\)</span>
time.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em></p>
<ul>
<li><p>Each of <span class="math inline">\(N\)</span> elements passes
through <code>next()</code> exactly once</p></li>
<li><p>Each <code>next()</code> performs:</p>
<ul>
<li><p>One extractMin(): <span class="math inline">\(O(\log
k)\)</span></p></li>
<li><p>Zero or one insert(): <span class="math inline">\(O(\log
k)\)</span></p></li>
</ul></li>
<li><p>Total: <span class="math inline">\(N \times O(\log k) = O(N \log
k)\)</span></p></li>
</ul>
<p> ◻</p>
</div>
<h1 id="space-complexity">Space Complexity</h1>
<div class="theorem">
<p><strong>Theorem 2</strong> (Space Complexity). <em>The heap-based
collating iterator uses <span class="math inline">\(O(k)\)</span>
auxiliary space.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em></p>
<ul>
<li><p>Heap stores at most <span class="math inline">\(k\)</span>
elements (one per iterator)</p></li>
<li><p>Array-based heap: <span class="math inline">\(k\)</span> entries
<span class="math inline">\(\times\)</span> (element reference +
iterator reference)</p></li>
<li><p>At 64-bit: <span class="math inline">\(k \times 16\)</span> bytes
<span class="math inline">\(= 16k\)</span> bytes</p></li>
<li><p>Input iterators provided by caller (not counted in auxiliary
space)</p></li>
<li><p>No other significant storage</p></li>
<li><p>Total: <span class="math inline">\(O(k)\)</span></p></li>
</ul>
<p> ◻</p>
</div>
<h1 id="correctness-proof">Correctness Proof</h1>
<h2 id="loop-invariant">Loop Invariant</h2>
<div class="invariant">
<p><strong>Invariant 1</strong> (Heap Invariant). <em>At the start of
each <code>next()</code> call:</em></p>
<ol>
<li><p><em>The heap <span class="math inline">\(H\)</span> contains
exactly one element from each non-exhausted input iterator</em></p></li>
<li><p><em>Each element in <span class="math inline">\(H\)</span> is the
minimum remaining element from its source iterator</em></p></li>
<li><p><em>All elements output so far form a non-decreasing
sequence</em></p></li>
<li><p><em>The minimum element in <span class="math inline">\(H\)</span>
is the global minimum across all remaining elements</em></p></li>
</ol>
</div>
<h2 id="proof-of-correctness">Proof of Correctness</h2>
<div class="proof">
<p><em>Proof by Induction.</em> <strong>Base Case
(Initialization):</strong></p>
<ul>
<li><p>Extract first element from each non-empty iterator</p></li>
<li><p>Insert into heap</p></li>
<li><p>Heap size <span class="math inline">\(=\)</span> number of
non-empty iterators <span class="math inline">\(\leq k\)</span></p></li>
<li><p>Each heap element is the first (minimum) of its iterator</p></li>
<li><p>No elements output yet (vacuously sorted)</p></li>
<li><p>Invariant holds</p></li>
</ul>
<p><strong>Inductive Step (Maintenance):</strong></p>
<p>Assume invariant holds at start of iteration <span
class="math inline">\(i\)</span>. After extractMin() and potential
insert():</p>
<ul>
<li><p>Let <span class="math inline">\(e =\)</span> extractMin() from
heap</p></li>
<li><p>By heap property: <span class="math inline">\(e \leq\)</span> all
other elements in <span class="math inline">\(H\)</span></p></li>
<li><p>By invariant part (2): elements in <span
class="math inline">\(H\)</span> are minimums of their
iterators</p></li>
<li><p>Therefore: <span class="math inline">\(e \leq\)</span> all
remaining elements globally</p></li>
<li><p>By invariant part (3): previous output sorted</p></li>
<li><p>By transitivity: <span class="math inline">\(e \geq\)</span>
previous output (since <span class="math inline">\(e\)</span> was
minimum then)</p></li>
<li><p>Appending <span class="math inline">\(e\)</span> maintains sorted
output</p></li>
<li><p>After extracting <span class="math inline">\(e\)</span> from
iterator <span class="math inline">\(I\)</span>:</p>
<ul>
<li><p>If <span class="math inline">\(I\)</span> not exhausted: insert
next element from <span class="math inline">\(I\)</span></p></li>
<li><p>This element is new minimum of <span
class="math inline">\(I\)</span> (since <span
class="math inline">\(I\)</span> sorted)</p></li>
<li><p>If <span class="math inline">\(I\)</span> exhausted: no insertion
(removes <span class="math inline">\(I\)</span> from
consideration)</p></li>
</ul></li>
<li><p>Heap still has one element per non-exhausted iterator</p></li>
<li><p>Invariant maintained</p></li>
</ul>
<p><strong>Termination:</strong></p>
<ul>
<li><p>Iteration ends when heap empty</p></li>
<li><p>Heap empty <span class="math inline">\(\Leftrightarrow\)</span>
all iterators exhausted (by invariant part 1)</p></li>
<li><p>All <span class="math inline">\(N\)</span> elements extracted
(conservation of elements)</p></li>
<li><p>Output is sorted (invariant part 3 throughout)</p></li>
</ul>
<p>Therefore, the algorithm is correct. <span
class="math inline">\(\square\)</span> ◻</p>
</div>
<h1 id="constant-factors">Constant Factors</h1>
<h2 id="comparison-operations">Comparison Operations</h2>
<p>For each <code>next()</code> call:</p>
<ul>
<li><p>extractMin() sift-down: <span class="math inline">\(\sim 2 \log_2
k\)</span> comparisons</p></li>
<li><p>insert() sift-up: <span class="math inline">\(\sim \log_2
k\)</span> comparisons</p></li>
<li><p>Total per element: <span class="math inline">\(\sim 3 \log_2
k\)</span> comparisons</p></li>
</ul>
<p>Practical examples:</p>
<ul>
<li><p><span class="math inline">\(k = 2\)</span>: 3 comparisons (binary
merge)</p></li>
<li><p><span class="math inline">\(k = 10\)</span>: 10
comparisons</p></li>
<li><p><span class="math inline">\(k = 100\)</span>: 20
comparisons</p></li>
<li><p><span class="math inline">\(k = 1000\)</span>: 30
comparisons</p></li>
</ul>
<h2 id="memory-access-pattern">Memory Access Pattern</h2>
<p>Array-based heap (zero-indexed):</p>
<ul>
<li><p>Parent of node <span class="math inline">\(i\)</span>: <span
class="math inline">\(\lfloor (i-1)/2 \rfloor\)</span></p></li>
<li><p>Children of node <span class="math inline">\(i\)</span>: <span
class="math inline">\(2i+1, 2i+2\)</span></p></li>
</ul>
<p>For <span class="math inline">\(k = 100\)</span>:</p>
<ul>
<li><p>Heap fits in <span class="math inline">\(\sim 13\)</span> cache
lines (64-byte lines)</p></li>
<li><p>Entire structure in L1 cache (32KB typical)</p></li>
<li><p>Sequential array access (prefetcher friendly)</p></li>
<li><p><span class="math inline">\(\sim 3 \log_2 k \approx 20\)</span>
memory accesses per element</p></li>
</ul>
<h2 id="branch-mispredictions">Branch Mispredictions</h2>
<ul>
<li><p>Heap path unpredictable: <span class="math inline">\(\log_2
k\)</span> branches</p></li>
<li><p>Each has <span class="math inline">\(\sim 50\%\)</span>
misprediction rate (data-dependent)</p></li>
<li><p>Modern CPUs: <span class="math inline">\(\sim 15\)</span>-20
cycle penalty per mispredict</p></li>
<li><p>For <span class="math inline">\(k = 100\)</span>: <span
class="math inline">\(\sim 3-4\)</span> mispredicts per element</p></li>
</ul>
<h1 id="lower-bound">Lower Bound</h1>
<div class="theorem">
<p><strong>Theorem 3</strong> (Comparison Lower Bound). <em>Any
comparison-based k-way merge algorithm requires <span
class="math inline">\(\Omega(N \log k)\)</span> comparisons.</em></p>
</div>
<div class="proof">
<p><em>Proof Sketch.</em></p>
<ul>
<li><p>For each element output, must determine which of <span
class="math inline">\(k\)</span> iterators supplies it</p></li>
<li><p>Decision tree has <span class="math inline">\(k\)</span> choices
per element</p></li>
<li><p>Height of decision tree: <span class="math inline">\(\log_2
k\)</span></p></li>
<li><p>Must make decision for each of <span
class="math inline">\(N\)</span> elements</p></li>
<li><p>Total: <span class="math inline">\(\Omega(N \log k)\)</span>
comparisons required</p></li>
</ul>
<p>Therefore, heap-based algorithm is asymptotically optimal. <span
class="math inline">\(\square\)</span> ◻</p>
</div>
<h1 id="references">References</h1>
<ul>
<li><p>Knuth, <em>The Art of Computer Programming, Vol 3: Sorting and
Searching</em>, Section 5.4.1</p></li>
<li><p>Cormen et al., <em>Introduction to Algorithms</em> (CLRS),
Chapter 6: Heapsort</p></li>
<li><p>Knuth TAOCP Vol 1, Section 2.2.3: Trees</p></li>
</ul>
</body>
</html>
