<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Research Artifact" />
  <title>Collating Iterator: Comparative Complexity Analysis</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/water.css" />
  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Collating Iterator: Comparative Complexity
Analysis</h1>
<p class="author">Research Artifact</p>
<p class="date">October 2025</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#design-alternatives" id="toc-design-alternatives">Design
Alternatives</a></li>
<li><a href="#asymptotic-comparison"
id="toc-asymptotic-comparison">Asymptotic Comparison</a></li>
<li><a href="#constant-factor-analysis"
id="toc-constant-factor-analysis">Constant Factor Analysis</a>
<ul>
<li><a href="#branch-mispredictions"
id="toc-branch-mispredictions">Branch Mispredictions</a></li>
</ul></li>
<li><a href="#empirical-crossover-points"
id="toc-empirical-crossover-points">Empirical Crossover Points</a>
<ul>
<li><a href="#small-k-k-leq-8" id="toc-small-k-k-leq-8">Small <span
class="math inline">\(k\)</span> (<span class="math inline">\(k \leq
8\)</span>)</a></li>
<li><a href="#medium-k-8-k-leq-1000"
id="toc-medium-k-8-k-leq-1000">Medium <span
class="math inline">\(k\)</span> (<span class="math inline">\(8 &lt; k
\leq 1000\)</span>)</a></li>
<li><a href="#large-k-k-1000" id="toc-large-k-k-1000">Large <span
class="math inline">\(k\)</span> (<span class="math inline">\(k &gt;
1000\)</span>)</a></li>
</ul></li>
<li><a href="#memory-hierarchy-analysis"
id="toc-memory-hierarchy-analysis">Memory Hierarchy Analysis</a>
<ul>
<li><a href="#cache-behavior-p4athlon-era"
id="toc-cache-behavior-p4athlon-era">Cache Behavior (P4/Athlon
Era)</a></li>
<li><a href="#spatial-locality" id="toc-spatial-locality">Spatial
Locality</a></li>
</ul></li>
<li><a href="#implementation-complexity"
id="toc-implementation-complexity">Implementation Complexity</a>
<ul>
<li><a href="#maintenance-considerations"
id="toc-maintenance-considerations">Maintenance Considerations</a></li>
</ul></li>
<li><a href="#trade-off-summary" id="toc-trade-off-summary">Trade-off
Summary</a></li>
<li><a href="#recommendation" id="toc-recommendation">Recommendation</a>
<ul>
<li><a href="#primary-choice-binary-min-heap-array-based"
id="toc-primary-choice-binary-min-heap-array-based">Primary Choice:
Binary Min-Heap (Array-Based)</a></li>
<li><a href="#when-to-deviate" id="toc-when-to-deviate">When to
Deviate</a></li>
<li><a href="#final-verdict" id="toc-final-verdict">Final
Verdict</a></li>
</ul></li>
<li><a href="#references" id="toc-references">References</a></li>
</ul>
</nav>
<h1 id="design-alternatives">Design Alternatives</h1>
<p>Five primary approaches for k-way merge:</p>
<ol>
<li><p><strong>Binary Min-Heap</strong>: Array-based heap with <span
class="math inline">\(O(\log k)\)</span> operations</p></li>
<li><p><strong>Tournament Tree</strong>: Pointer-based tree with winner
propagation</p></li>
<li><p><strong>Linear Scan</strong>: Brute-force minimum search across
<span class="math inline">\(k\)</span> iterators</p></li>
<li><p><strong>Pairwise Reduction</strong>: Recursive binary merge
tree</p></li>
<li><p><strong>Sorted Array</strong>: Materialize all elements, sort,
return</p></li>
</ol>
<h1 id="asymptotic-comparison">Asymptotic Comparison</h1>
<div id="tab:asymptotic">
<table>
<caption>Asymptotic complexity comparison</caption>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Design</strong></th>
<th style="text-align: center;"><strong>Init</strong></th>
<th style="text-align: center;"><strong>next()</strong></th>
<th style="text-align: center;"><strong>hasNext()</strong></th>
<th style="text-align: center;"><strong>Total</strong></th>
<th style="text-align: center;"><strong>Space</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Min-Heap</td>
<td style="text-align: center;"><span class="math inline">\(O(k \log
k)\)</span></td>
<td style="text-align: center;"><span class="math inline">\(O(\log
k)\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(O(1)\)</span></td>
<td style="text-align: center;"><span class="math inline">\(O(N \log
k)\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(O(k)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Tournament</td>
<td style="text-align: center;"><span
class="math inline">\(O(k)\)</span></td>
<td style="text-align: center;"><span class="math inline">\(O(\log
k)\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(O(1)\)</span></td>
<td style="text-align: center;"><span class="math inline">\(O(N \log
k)\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(O(k)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Linear Scan</td>
<td style="text-align: center;"><span
class="math inline">\(O(k)\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(O(k)\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(O(1)\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(O(Nk)\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(O(k)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Pairwise</td>
<td style="text-align: center;"><span
class="math inline">\(O(k)\)</span></td>
<td style="text-align: center;"><span class="math inline">\(O(\log
k)\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(O(1)\)</span></td>
<td style="text-align: center;"><span class="math inline">\(O(N \log
k)\)</span></td>
<td style="text-align: center;"><span class="math inline">\(O(k \log
k)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Sorted Array</td>
<td style="text-align: center;"><span class="math inline">\(O(N \log
N)\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(O(1)\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(O(1)\)</span></td>
<td style="text-align: center;"><span class="math inline">\(O(N \log
N)\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(O(N)\)</span></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Winner (Asymptotic)</strong>: Min-Heap achieves optimal <span
class="math inline">\(O(N \log k)\)</span> with minimal <span
class="math inline">\(O(k)\)</span> space.</p>
<h1 id="constant-factor-analysis">Constant Factor Analysis</h1>
<div id="tab:constants">
<table>
<caption>Constant factors per next() operation</caption>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Design</strong></th>
<th style="text-align: center;"><strong>Comparisons</strong></th>
<th style="text-align: center;"><strong>Memory Access</strong></th>
<th style="text-align: center;"><strong>Allocations</strong></th>
<th style="text-align: center;"><strong>Cache Lines (<span
class="math inline">\(k=100\)</span>)</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Min-Heap</td>
<td style="text-align: center;"><span class="math inline">\(\sim 2
\log_2 k\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\sim 3
\log_2 k\)</span></td>
<td style="text-align: center;">0 (reuse)</td>
<td style="text-align: center;"><span class="math inline">\(\lceil k/8
\rceil \approx 13\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Tournament</td>
<td style="text-align: center;"><span class="math inline">\(\sim \log_2
k\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\sim 2
\log_2 k\)</span></td>
<td style="text-align: center;"><span class="math inline">\(k-1\)</span>
nodes</td>
<td style="text-align: center;"><span class="math inline">\(k/2 \approx
50\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Linear Scan</td>
<td style="text-align: center;"><span
class="math inline">\(k\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(2k\)</span></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"><span class="math inline">\(\lceil k/8
\rceil \approx 13\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Pairwise</td>
<td style="text-align: center;"><span class="math inline">\(2 \log_2
k\)</span></td>
<td style="text-align: center;">Variable</td>
<td style="text-align: center;"><span
class="math inline">\(O(k)\)</span> temps</td>
<td style="text-align: center;">Variable</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Sorted Array</td>
<td style="text-align: center;">0 (pre-sorted)</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"><span class="math inline">\(N\)</span>
(copy all)</td>
<td style="text-align: center;"><span class="math inline">\(N/8\)</span>
(entire array)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="branch-mispredictions">Branch Mispredictions</h2>
<ul>
<li><p><strong>Min-Heap</strong>: <span class="math inline">\(\sim
\log_2 k\)</span> per next() (unpredictable heap path)</p></li>
<li><p><strong>Tournament</strong>: <span class="math inline">\(\sim
\log_2 k\)</span> (tree path)</p></li>
<li><p><strong>Linear Scan</strong>: <span class="math inline">\(\sim
k/2\)</span> (unpredictable minimum location)</p></li>
<li><p><strong>Pairwise</strong>: <span class="math inline">\(\sim
\log_2 k\)</span> (merge recursion)</p></li>
<li><p><strong>Sorted Array</strong>: <span class="math inline">\(\sim
0\)</span> (sequential access)</p></li>
</ul>
<h1 id="empirical-crossover-points">Empirical Crossover Points</h1>
<h2 id="small-k-k-leq-8">Small <span class="math inline">\(k\)</span>
(<span class="math inline">\(k \leq 8\)</span>)</h2>
<p>Linear scan becomes competitive: <span
class="math display">\[\begin{aligned}
\text{Linear scan cost} &amp;= k \text{ comparisons} \\
\text{Heap cost} &amp;\approx 3 \log_2 k \text{ operations}
\end{aligned}\]</span></p>
<p>For <span class="math inline">\(k = 8\)</span>:</p>
<ul>
<li><p>Linear: 8 comparisons</p></li>
<li><p>Heap: <span class="math inline">\(3 \log_2 8 = 9\)</span>
operations</p></li>
</ul>
<p><strong>Crossover</strong>: <span class="math inline">\(k \approx
8\)</span>-10 depending on comparison cost.</p>
<p><strong>Consideration</strong>: Entire state (8 iterators) fits in L1
cache (192 bytes), branch predictor may learn patterns.</p>
<h2 id="medium-k-8-k-leq-1000">Medium <span
class="math inline">\(k\)</span> (<span class="math inline">\(8 &lt; k
\leq 1000\)</span>)</h2>
<p>Heap dominates:</p>
<ul>
<li><p><span class="math inline">\(k = 100\)</span>: Heap = 13 ops vs
Linear = 100 ops (7.7<span class="math inline">\(\times\)</span>
faster)</p></li>
<li><p>Array-based heap: excellent cache locality</p></li>
<li><p>Tournament tree: pointer chasing kills performance</p></li>
</ul>
<p><strong>Recommendation</strong>: Binary min-heap (array-based)</p>
<h2 id="large-k-k-1000">Large <span class="math inline">\(k\)</span>
(<span class="math inline">\(k &gt; 1000\)</span>)</h2>
<p>Heap remains optimal:</p>
<ul>
<li><p><span class="math inline">\(k = 1024\)</span>: <span
class="math inline">\(\log_2 k \approx 10\)</span> operations</p></li>
<li><p>Heap size: <span class="math inline">\(1024 \times 24\)</span>
bytes <span class="math inline">\(= 24\)</span>KB (fits L2
cache)</p></li>
<li><p>Still vastly better than <span class="math inline">\(O(k) =
1000\)</span> operations</p></li>
</ul>
<p><strong>Recommendation</strong>: Heap still optimal; segmented PQ
only if empirically bottlenecked.</p>
<h1 id="memory-hierarchy-analysis">Memory Hierarchy Analysis</h1>
<h2 id="cache-behavior-p4athlon-era">Cache Behavior (P4/Athlon Era)</h2>
<p><strong>L1 Cache (32KB typical)</strong>:</p>
<ul>
<li><p><span class="math inline">\(k \leq 1300\)</span>: Entire heap
fits (<span class="math inline">\(1300 \times 24 \approx
31\)</span>KB)</p></li>
<li><p>Array-based heap: sequential strides,
prefetcher-friendly</p></li>
</ul>
<p><strong>L2 Cache (256KB typical)</strong>:</p>
<ul>
<li><p><span class="math inline">\(k \leq 10000\)</span>: Heap fits in
L2</p></li>
<li><p>Linear scan: <span class="math inline">\(k &gt; 1000\)</span>
exceeds cache but still <span class="math inline">\(O(k)\)</span> memory
accesses</p></li>
</ul>
<p><strong>Memory Bandwidth</strong>:</p>
<ul>
<li><p>Heap: <span class="math inline">\(\sim 3 \log_2 k\)</span> memory
ops per element</p></li>
<li><p>Linear scan: <span class="math inline">\(2k\)</span> memory ops
per element</p></li>
<li><p><span class="math inline">\(k = 100\)</span>: Heap = 20 ops vs
Scan = 200 ops (10<span class="math inline">\(\times\)</span>
difference)</p></li>
</ul>
<h2 id="spatial-locality">Spatial Locality</h2>
<table>
<caption>Spatial locality comparison</caption>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Design</strong></th>
<th style="text-align: center;"><strong>Layout</strong></th>
<th style="text-align: center;"><strong>Locality</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Min-Heap</td>
<td style="text-align: center;">Array (contiguous)</td>
<td style="text-align: center;">Excellent</td>
</tr>
<tr class="even">
<td style="text-align: left;">Tournament</td>
<td style="text-align: center;">Pointer-based tree</td>
<td style="text-align: center;">Poor</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Linear Scan</td>
<td style="text-align: center;">Array of references</td>
<td style="text-align: center;">Good</td>
</tr>
<tr class="even">
<td style="text-align: left;">Pairwise</td>
<td style="text-align: center;">Temporary arrays</td>
<td style="text-align: center;">Variable</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Sorted Array</td>
<td style="text-align: center;">Single array</td>
<td style="text-align: center;">Excellent</td>
</tr>
</tbody>
</table>
<h1 id="implementation-complexity">Implementation Complexity</h1>
<table>
<caption>Implementation complexity comparison</caption>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Design</strong></th>
<th style="text-align: center;"><strong>LoC</strong></th>
<th style="text-align: center;"><strong>Tricky Logic</strong></th>
<th style="text-align: center;"><strong>Test Burden</strong></th>
<th style="text-align: center;"><strong>API Clarity</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Min-Heap</td>
<td style="text-align: center;"><span class="math inline">\(\sim
60\)</span></td>
<td style="text-align: center;">Heapify, sift ops</td>
<td style="text-align: center;">Medium</td>
<td style="text-align: center;">Clean</td>
</tr>
<tr class="even">
<td style="text-align: left;">Tournament</td>
<td style="text-align: center;"><span class="math inline">\(\sim
100\)</span></td>
<td style="text-align: center;">Tree rebuild, winner path</td>
<td style="text-align: center;">High</td>
<td style="text-align: center;">Medium</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Linear Scan</td>
<td style="text-align: center;"><span class="math inline">\(\sim
30\)</span></td>
<td style="text-align: center;">None</td>
<td style="text-align: center;">Low</td>
<td style="text-align: center;">Very clean</td>
</tr>
<tr class="even">
<td style="text-align: left;">Pairwise</td>
<td style="text-align: center;"><span class="math inline">\(\sim
80\)</span></td>
<td style="text-align: center;">Recursion depth, temp mgmt</td>
<td style="text-align: center;">Medium-high</td>
<td style="text-align: center;">Medium</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Sorted Array</td>
<td style="text-align: center;"><span class="math inline">\(\sim
20\)</span></td>
<td style="text-align: center;">None (trivial)</td>
<td style="text-align: center;">Low</td>
<td style="text-align: center;">Violates lazy</td>
</tr>
</tbody>
</table>
<h2 id="maintenance-considerations">Maintenance Considerations</h2>
<ul>
<li><p><strong>Min-Heap</strong>: Well-known, easy to debug, standard
data structure</p></li>
<li><p><strong>Tournament</strong>: Obscure, hard to reason about,
complex tree invariants</p></li>
<li><p><strong>Linear Scan</strong>: Trivially correct, but <span
class="math inline">\(O(Nk)\)</span> unacceptable for
production</p></li>
<li><p><strong>Pairwise</strong>: Clever but not obviously correct,
space overhead</p></li>
<li><p><strong>Sorted Array</strong>: Breaks lazy contract (materializes
all data upfront)</p></li>
</ul>
<h1 id="trade-off-summary">Trade-off Summary</h1>
<table>
<caption>Multi-criteria comparison (<span
class="math inline">\(\checkmark\checkmark\)</span> = excellent, <span
class="math inline">\(\checkmark\)</span> = good, <span
class="math inline">\(\times\)</span> = poor)</caption>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Criterion</strong></th>
<th style="text-align: center;"><strong>Heap</strong></th>
<th style="text-align: center;"><strong>Tournament</strong></th>
<th style="text-align: center;"><strong>Linear</strong></th>
<th style="text-align: center;"><strong>Pairwise</strong></th>
<th style="text-align: center;"><strong>Array</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Time Complexity</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span
class="math inline">\(\times\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">Space Complexity</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span
class="math inline">\(\times\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Constant Factors</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span
class="math inline">\(\times\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">Cache Behavior</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span
class="math inline">\(\times\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span
class="math inline">\(\times\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Implementation</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span
class="math inline">\(\times\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">Lazy Evaluation</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span
class="math inline">\(\times\)</span></td>
</tr>
</tbody>
</table>
<h1 id="recommendation">Recommendation</h1>
<h2 id="primary-choice-binary-min-heap-array-based">Primary Choice:
Binary Min-Heap (Array-Based)</h2>
<p><strong>Justification</strong>:</p>
<ol>
<li><p><strong>Asymptotic Optimal</strong>: <span
class="math inline">\(O(N \log k)\)</span> matches theoretical lower
bound</p></li>
<li><p><strong>Excellent Constants</strong>: <span
class="math inline">\(\sim 2 \log_2 k\)</span> comparisons
practical</p></li>
<li><p><strong>Cache-Friendly</strong>: Array storage, sequential access
patterns</p></li>
<li><p><strong>Scalable</strong>: Works well for <span
class="math inline">\(k \in [2, 10000+]\)</span></p></li>
<li><p><strong>Simple</strong>: Well-understood data structure, moderate
implementation complexity</p></li>
<li><p><strong>Memory Efficient</strong>: <span
class="math inline">\(O(k)\)</span> space, no allocations per
element</p></li>
</ol>
<h2 id="when-to-deviate">When to Deviate</h2>
<ul>
<li><p><strong><span class="math inline">\(k = 2\)</span></strong>:
Specialize to simple binary merge (no heap overhead)</p></li>
<li><p><strong><span class="math inline">\(k \leq 8\)</span> and known
static</strong>: Consider branchless SIMD min
(micro-optimization)</p></li>
<li><p><strong>Stability required</strong>: Use tournament tree with
tie-breaking on iterator index</p></li>
<li><p><strong><span class="math inline">\(k &gt;
10000\)</span></strong>: Profile first; segmented PQ unlikely to help
unless empirically proven</p></li>
</ul>
<h2 id="final-verdict">Final Verdict</h2>
<p>Binary min-heap is the <strong>Pareto-optimal solution</strong> for
the general case:</p>
<ul>
<li><p><span class="math inline">\(k &gt; 8\)</span> (non-trivial
merge)</p></li>
<li><p>Lazy evaluation required (streaming data)</p></li>
<li><p>No stability constraint (order of ties unspecified)</p></li>
<li><p>Standard comparator-based ordering</p></li>
</ul>
<h1 id="references">References</h1>
<ul>
<li><p>Knuth TAOCP Vol 3, Section 5.4.1: External Sorting</p></li>
<li><p>Hennessy &amp; Patterson, <em>Computer Architecture: A
Quantitative Approach</em> (3rd ed, 2002)</p></li>
<li><p>Sedgewick &amp; Wayne, <em>Algorithms</em> (4th ed): Priority
Queues</p></li>
</ul>
</body>
</html>
